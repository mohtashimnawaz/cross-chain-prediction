import * as anchor from '@project-serum/anchor';
import { Program } from '@project-serum/anchor';
import { createMint, getOrCreateAssociatedTokenAccount, mintTo, TOKEN_PROGRAM_ID } from '@solana/spl-token';
import fs from 'fs';
import path from 'path';

describe('prediction_market E2E from EVM', () => {
  // Use local provider
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.PredictionMarket as Program<any>;

  it('consumes compose message generated by EVM adapter', async () => {
    // Read compose message generated by the EVM side
    const file = path.resolve(__dirname, '..', '..', 'e2e', 'out', 'compose.json');
    if (!fs.existsSync(file)) {
      throw new Error(`compose.json not found; run the EVM script to generate it: cd contracts && npx hardhat run --network localhost scripts/generate_compose.js`);
    }
    const payloadObj = JSON.parse(fs.readFileSync(file, 'utf8'));
    // payloadObj.composeHex is a hex string like 0x...
    const composeHex = payloadObj.composeHex;
    const payloadBuf = Buffer.from(composeHex.replace(/^0x/, ''), 'hex');

    // Create a market and vault
    const marketKeypair = anchor.web3.Keypair.generate();
    const marketId = payloadObj.marketId || 42;

    const [vaultPda, _vaultBump] = await anchor.web3.PublicKey.findProgramAddress(
      [Buffer.from('vault'), marketKeypair.publicKey.toBytes()],
      program.programId
    );

    await program.rpc.initializeMarket(new anchor.BN(marketId), {
      accounts: {
        market: marketKeypair.publicKey,
        vault: vaultPda,
        payer: provider.wallet.publicKey,
        systemProgram: anchor.web3.SystemProgram.programId,
      },
      signers: [marketKeypair],
    });

    // Create a test USDC mint and mint some tokens into the vault's token account
    const mint = await createMint(provider.connection, provider.wallet.payer, provider.wallet.publicKey, null, 6);
    const vaultTokenAccount = await getOrCreateAssociatedTokenAccount(provider.connection, provider.wallet.payer, mint, vaultPda);

    // Mint 1000 tokens to the vault
    await mintTo(provider.connection, provider.wallet.payer, mint, vaultTokenAccount.address, provider.wallet.publicKey, 1000);

    // Derive expected user position PDA from payload (extract user evm addr and market id LE)
    // user evm address is located at bytes 12..32 of a standard ABI encoded 32-byte word
    if (payloadBuf.length !== 96) throw new Error('unexpected compose payload length');
    const userEvmAddress = payloadBuf.slice(12, 32); // 20 bytes

    const marketIdLE = Buffer.alloc(8);
    marketIdLE.writeBigUInt64LE(BigInt(marketId));

    const [userPosPda, _userPosBump] = await anchor.web3.PublicKey.findProgramAddress(
      [Buffer.from('userpos'), marketIdLE, userEvmAddress],
      program.programId
    );

    // Call lz_compose as the executor (use provider wallet)
    await program.rpc.lzCompose(Array.from(payloadBuf), {
      accounts: {
        market: marketKeypair.publicKey,
        vault: vaultPda,
        tokenAccount: vaultTokenAccount.address,
        usdcMint: mint,
        userPosition: userPosPda,
        executor: provider.wallet.publicKey,
        tokenProgram: TOKEN_PROGRAM_ID,
        systemProgram: anchor.web3.SystemProgram.programId,
      },
    });

    // Verify state updates
    const marketAccount = await program.account.marketAccount.fetch(marketKeypair.publicKey);
    if (BigInt(marketAccount.outcomes[Number(payloadObj.outcome)]) === BigInt(0)) {
      throw new Error('outcome not updated after lz_compose');
    }

    const userPosAccountInfo = await provider.connection.getAccountInfo(userPosPda);
    if (!userPosAccountInfo) throw new Error('user position account not found');
    const data = userPosAccountInfo.data;
    const parsedMarketId = Number(data.readBigUInt64LE(0));
    if (parsedMarketId !== marketId) throw new Error('user pos market id mismatch');
  });
});